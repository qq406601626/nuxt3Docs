---
description: "Nuxt supports different rendering modes. Each one has pros and cons covered in this section."
---

# 渲染模式

浏览器和服务器都可以解析JavaScript代码将Vue.js组件渲染为HTML元素。这个过程称为**rendering**。Nuxt支持**客户端渲染**和**通用渲染**两种方式。这两种方式都有各自的优点和缺点，我们将在本节中介绍。

## 只在客户端进行渲染

传统的Vue.js应用程序默认在浏览器（或**客户端**）中进行渲染。然后，在浏览器下载和解析包含创建当前界面指令的所有JavaScript代码后，Vue.js生成HTML元素。

![用户必须等待浏览器下载、解析和执行JavaScript代码，才能看到页面的内容。](/assets/docs/concepts/rendering/csr.svg)

尽管这种技术允许构建复杂和动态的UI，并实现平滑的页面过渡，但它也有不同的优点和缺点：

### 优点：

- **开发速度**：在完全在客户端进行开发时，我们不必担心代码在服务器上的兼容性，例如使用仅限浏览器的API，如`window`对象。
- **成本较低**：运行服务器会增加基础设施成本，因为您需要在支持JavaScript的平台上运行。而客户端应用程序可以托管在任何只提供HTML、CSS和JavaScript文件的静态服务器上。
- **离线支持**：因为代码完全在浏览器中运行，所以在没有网络连接时可以良好地继续工作。

### 缺点：

- **性能**：用户必须等待浏览器下载、解析和运行JavaScript文件。根据网络下载速度和用户设备的解析和执行速度，这可能需要一些时间并影响用户的体验。
- **搜索引擎优化**：通过客户端渲染提供内容的索引和更新比使用服务器渲染的HTML文档需要更长的时间。这与我们讨论的性能缺点有关，因为搜索引擎爬虫不会等待界面完全渲染后再进行首次索引。使用纯客户端渲染，您的内容在搜索结果页面上显示和更新所需的时间会更长。

### 示例

客户端渲染适用于不需要进行索引或用户经常访问的高度交互式**Web应用程序**。它可以利用浏览器缓存，在后续访问中跳过下载阶段，例如**SaaS、后台管理应用程序或在线游戏**。

## 通用渲染

启用通用（客户端+服务器端）渲染时，当浏览器请求一个URL时，服务器会返回一个完全渲染的HTML页面给浏览器。无论页面是预先生成并缓存还是即时渲染，Nuxt在某个时刻在服务器环境中运行了JavaScript（Vue.js）代码，生成了一个HTML文档。用户立即获得我们应用程序的内容，与客户端渲染相反。这一步类似于由PHP或Ruby应用程序执行的传统**服务器端渲染**。

为了不失去客户端渲染方法的优点，如动态界面和页面过渡效果，客户端在下载HTML文档后，后台加载运行在服务器上的JavaScript代码。浏览器再次解释它（因此称为**通用渲染**），Vue.js接管文档并启用交互功能。

在浏览器中将静态页面变得具有交互性的过程称为“水合”。

通用渲染允许Nuxt应用程序在保留客户端渲染优点的同时提供快速的页面加载时间。此外，由于内容已经存在于HTML文档中，爬虫可以在没有额外开销的情况下对其进行索引。

![用户可以在加载HTML文档时访问静态内容。然后，水合过程允许页面的交互性。](/assets/docs/concepts/rendering/ssr.svg)

### 优点

- **性能**: 用户可以立即访问页面的内容，因为浏览器可以比JavaScript生成的内容更快地显示静态内容。同时，当进行水合过程时，Nuxt保留了Web应用程序的交互性。
- **搜索引擎优化**: 通用渲染将整个HTML内容作为经典服务器应用程序传递给浏览器。网络爬虫可以直接索引页面的内容，这使得通用渲染成为快速索引任何内容的绝佳选择。

### 缺点

- **开发限制:** 服务器和浏览器环境不提供相同的API，编写可以在两个环境中无缝运行的代码可能会很棘手。幸运的是，Nuxt提供了指南和特定变量，帮助您确定代码在哪个环境中执行。
- **成本:** 为了实时渲染页面，需要运行一个服务器。这会增加类似于传统服务器的每月成本。然而，由于通用渲染并在客户端导航时由浏览器接管，服务器调用大大减少了。

::alert
要了解更多关于如何编写无水合不匹配的Vue代码的示例，请参阅[Vue文档](https://vuejs.org/guide/scaling-up/ssr.html#hydration-mismatch)。
::

### 示例

通用渲染非常灵活，几乎适用于任何用例，特别适合面向内容的网站：**博客、营销网站、作品集、电子商务网站和市场**。

## 总结

客户端渲染和通用渲染是在浏览器中显示界面的不同策略。

默认情况下，Nuxt使用**通用渲染**来提供更好的用户体验和性能，并优化搜索引擎索引，但您可以在[一行配置](/docs/api/configuration/nuxt-config#ssr)中切换渲染模式。

## 即将推出的Nuxt 3

在大多数情况下，Nuxt 2中执行的通用渲染提供了良好的用户和开发者体验。然而，Nuxt 3通过引入混合渲染和边缘渲染将通用渲染推向了一个新的高度。

### 混合渲染

混合渲染允许针对每个路由使用不同的缓存规则，并使用**路由规则**来决定服务器如何响应给定URL的新请求。

### 在CDN Edge Workers上进行渲染

传统上，只有使用Node.js才能进行服务器端和通用渲染。Nuxt 3通过直接在CDN边缘工作器中渲染代码将其推上一个新的层次，从而降低延迟和成本。

Nitro是驱动Nuxt 3的新的[服务器引擎](/docs/guide/concepts/server-engine)。它支持Node.js、Deno、Workers等多个平台。Nitro的设计是平台无关的，可以在边缘处渲染Nuxt应用程序，更靠近用户，实现复制和进一步的优化。

### 路由规则

> 🧪 路由规则仍在积极开发中，可能会有变化。

以前，Nuxt应用程序和服务器的每个路由/页面必须使用相同的渲染模式，即客户端渲染或通用渲染。但在各种情况下，某些页面可能需要在构建时生成，而其他页面应该在客户端渲染。例如，想象一个带有管理员部分的内容网站。每个内容页面应该是主要静态的，只需生成一次，但管理员部分需要注册并更像是动态应用程序。

Nuxt 3从rc.12版本开始提供路由规则和混合渲染支持的公共测试版。使用路由规则，您可以为一组Nuxt路由定义规则，根据路由更改渲染模式或分配缓存策略！Nuxt服务器将自动注册相应的中间件，并使用[nitro缓存层](https://nitro.unjs.io/guide/introduction/cache)包装路由。在可能的情况下，路由规则将自动应用于部署平台的本机规则（目前支持Netlify和Vercel）。

- `重定向（redirect）`- 定义服务器端重定向。
- `服务器端渲染（ssr）`- 禁用应用程序的部分部分的服务器端渲染，并使其仅支持SPA（`ssr: false`）。
- `跨域资源共享（cors）`- 使用`cors: true`自动添加cors标头-您可以通过覆盖`headers`来自定义输出。
- `标头（headers）`- 为站点的特定部分添加特定的标头-例如，您的资源。
- `static` and `swr` - `static`启用单个（按需）构建；`swr`启用静态构建，并持续一段可配置的时间（TTL）。（目前在Netlify上启用完整的增量静态生成，Vercel即将推出）

**示例:**

```ts
export default defineNuxtConfig({
  routeRules: {
    // Static page generated on-demand, revalidates in background
    '/blog/**': { swr: true },
    // Static page generated on-demand once
    '/articles/**': { static: true },
    // Set custom headers matching paths
    '/_nuxt/**': { headers: { 'cache-control': 's-maxage=0' } },
    // Render these routes with SPA
    '/admin/**': { ssr: false },
    // Add cors headers
    '/api/v1/**': { cors: true },
    // Add redirect headers
    '/old-page': { redirect: '/new-page' },
    '/old-page2': { redirect: { to: '/new-page', statusCode: 302 } }
  }
})
```
